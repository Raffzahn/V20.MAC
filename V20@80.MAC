; 8080 Macros for NEC V Series 8080 Emulation
; for Microsoft Macro Assembler 5.0 and later
; (C) Copyright H.Franke 2022

         .XCREF
         .XLIST

; Intended to enable use of 8080 code sniplets
; within 8086 code files 
;
; Instructions are standard 8080 mnemonics but
; prefixed by '@' to avoide name collisions with
; 8086/186 instructions of the same name
;
; Note that for address calculation 8080 code
; must be either in asegment of its own or ORGed
; according to it's use witnin the emulation
; address space or all labels have to be given
; relative to what the 8080 emulation will
; assume as start of memory.
;
; It's useful to remember that in emulation mode
; all code references are based on CS, taken from
; the BRKEM vector, while Memory references (M)
; are related to DS, either at time of BRKEM, or
; as changed within a CALLN function.
;
; RETEM and CALLN are not included but part of
; coresponding V20.MAC file.
;
; ----
;
; The usage of records is inspired by Intel's
; ASM86, and its CodeMacros, a language feature
; not availible for MASM - plus rather basic
; Argument wrangling
;

         IF1


; 8080 Emulation Management specific to NEC V20

; Native Mode instructions:

; "Break" to Emulation
BRKEM    MACRO   vector
         DB      00Fh,0FFh,vector
         ENDM


; Emulation (8080) Mode Instructions:

; Return from 8080 emulation to native (8086) mode
RETEM    MACRO
         DB      0EDh,0FDh
         ENDM

; Call native (8086) mode function from 8080 mode
CALLN    MACRO   vector
         DB      0EDh,0EDh,vector
         ENDM


; Helper Macos to encode register values

@@SREG80 MACRO    reg
;; Convert 16 bit reg names to bitstring
;; @@SREGV -> Register Encoding Value

         IFIDNI   <reg>,<B>
@@SREGV  =        000b
         ELSE
          IFIDNI   <reg>,<C>
@@SREGV  =        001b
          ELSE
           IFIDNI   <reg>,<D>
@@SREGV  =        010b
           ELSE
            IFIDNI  <reg>,<E>
@@SREGV  =        011b
            ELSE
             IFIDNI   <reg>,<H>
@@SREGV  =        100b
             ELSE
              IFIDNI   <reg>,<L>
@@SREGV  =        101b
              ELSE
               IFIDNI   <reg>,<M>
@@SREGV  =        110b
               ELSE
                IFIDNI   <reg>,<A>
@@SREGV  =        111b
                ELSE
;; Unknown Register Name
@@SREGV  =        000b    ;; Default Value to generate Base Instruction
                 IF2
         .ERR     Parameter [&reg] not a valid 8 bit register name
         %OUT     Parameter [&reg] not a valid 8 bit register name
                 ENDIF

                ENDIF
               ENDIF
              ENDIF
             ENDIF
            ENDIF
           ENDIF
          ENDIF
         ENDIF

         ENDM

@@DREG80 MACRO    reg,reg4
;; Convert 16 bit reg names to bitstring
;; reg4 defines what name is acceptable for 11b encoding
;; @@DREGV -> Register Encoding Value

         IFIDNI   <reg>,<B>
@@DREGV  =        00b
         ELSE
          IFIDNI   <reg>,<D>
@@DREGV  =        01b
          ELSE
           IFIDNI   <reg>,<H>
@@DREGV  =        10b
           ELSE
            IFIDNI   <reg>,<reg4>
@@DREGV  =        11b
            ELSE
;; Unknown or not allowed reister name
@@DREGV  =        00b     ;; Default Value to generate Base Instruction
             IF2
         .ERR     Parameter [&reg] not a valid double (16 bit) register name for this instruction
         %OUT     Parameter [&reg] not a valid double (16 bit) register name for this instruction
             ENDIF

            ENDIF
           ENDIF
          ENDIF
         ENDIF

         ENDM

; 8080 Instructions come in 6 different Formats

; Format 0 - OPC with no parameter
; Will be direct generated by DB statement

; Format 1 - Two Register OPC
@80_F1   RECORD @80_F1_OPC  : 2, @80_F1_DST : 3, @80_F1_SRC  : 3

; Format 2 - Register Pair OPC
@80_F2   RECORD @80_F1_OPC1 : 2, @80_F2_DST : 2, @80_F2_OPC2 : 4

; Format 3 - Single Register OPC, Variant 1
@80_F3   RECORD @80_F3_OPC  : 5, @80_F3_SRC : 3  (OP toward A)

; Format 4 - Single Register OPC, Variant 2
@80_F4   RECORD @80_F4_OPC1 : 2, @80_F4_DST : 3, @80_F4_OPC2 : 3

; Format 5 - Register Pair OPC, Variant 2 (Only LDAX/STAX)
@80_F5   RECORD @80_F5_OPC1 : 3, @80_F5_DST : 1, @80_F5_OPC2 : 4

; F1/F4 could use the same record definition
; But lets be clean :))

; Instructions sorted according to Intel's 1975
; "8080 Assembly Language Programming Manual"


; Carry Bit Instructions (p.14)

; Set Carry
@STC     MACRO
         DB       037h
         ENDM

; Cmplement Carry
@CMC     MACRO
         DB       03Fh
         ENDM


;Single Register Instructions (p.14)

; Increment Register or Memory
@INR     MACRO    dst
         @@SREG80 dst
         @80_F4   <00B,@@SREGV,100B>
         ENDM

;Decrement Register or Memory
@DCR     MACRO    dst
         @@SREG80 dst
         @80_F4   <00B,@@SREGV,101B>
         ENDM

; Complement Accumulator
@CMA     MACRO
         DB       02Fh
         ENDM

; Decimal Adjust Accumulator
@DAA     MACRO
         DB       027h
         ENDM

; NOP Instruction (p.16)

; No Operation
@NOP     MACRO
         DB       076h
         ENDM


; Data Transfer Instructions (p.16)

; Move Instruction
@MOV     MACRO    dst,src
         @@SREG80 dst
@@SREG1  =        @@SREGV
         @@SREG80 src
         @80_F1   <01B,@@SREG1,@@SREGV>
         ENDM

; LD/STAX - muss ich mir noch was Ã¼berlegen
;
; Store Accumlator
@STAX    MACRO    dst
         @@DREG80 dst
         IF       @@DREGV GT 01b
@@DREGV  =        00b     ;; Default Value to generate Base Instruction
          IF2
         .ERR     Parameter [&reg] not a valid register name for STAX
         %OUT     Parameter [&reg] not a valid register name for STAX
          ENDIF
         ENDIF
         @80_F5   <00B,@@DREGV AND 1b,0010B>
         ENDM

; Load Accumlator
@LDAX    MACRO    dst
         @@DREG80 dst
         IF       @@DREGV GT 01b
@@DREGV  =        00b     ;; Default Value to generate Base Instruction
          IF2
         .ERR     Parameter [&reg] not a valid register name for LDAX
         %OUT     Parameter [&reg] not a valid register name for LDAX
          ENDIF
         ENDIF
@@DREGV  =        @@DREGV AND 1b
         @80_F5   <00B,@@DREGV,1010B>
         ENDM

; Register or Memory to Accumulator instructions (p.17)

; Add Register or Memory to Accumulator
@ADD     MACRO    src
         @@SREG80 src
         @80_F3   <10000B,@@SREGV>
         ENDM

; Add Register or Memory to Accumulator With Carry
@ADC     MACRO    src
         @@SREG80 src
         @80_F3   <10001B,@@SREGV>
         ENDM

; Subtract Register or Memory From Accumulator
@SUB     MACRO    src
         @@SREG80 src
         @80_F3   <10010B,@@SREGV>
         ENDM

; Subtract Register or Memory From Accumulator With Borrow
@SBB     MACRO    src
         @@SREG80 src
         @80_F3   <10011B,@@SREGV>
         ENDM

;Logical and Register or Memory With Accumulator 
@ANA     MACRO    src
         @@SREG80 src
         @80_F3   <10100B,@@SREGV>
         ENDM

; Logical Exclusive-Or Register or Memory With Accumulator (Zero Accumulator)
@XRA     MACRO    src
         @@SREG80 src
         @80_F3   <10101B,@@SREGV>
         ENDM

; Logical or Register or Memory With Accumulator 
@ORA     MACRO    src
         @@SREG80 src
         @80_F3   <10110B,@@SREGV>
         ENDM

; Compare Register or Memory With Accumulator 
@CMP     MACRO    src
         @@SREG80 src
         @80_F3   <10111B,@@SREGV>
         ENDM

; Rotate Accumulator Instructions (p.21)

; Rotate Accumulator Left
@RLC     MACRO
         DB       007h
         ENDM

; Rotate Accumulator Right
@RRC     MACRO
         DB       00Fh
         ENDM

; Rotate Accumulator Left Through Carry
@RAL     MACRO
         DB       017h
         ENDM

; Rotate Accumulator Right Through Carry
@RAR     MACRO
         DB       01Fh
         ENDM

; Register Pair Instructions (p.22)

; Push Data Onto Stack
@PUSH    MACRO    src
         @@DREG80 src,PSW
         @80_F2   <11B,@@DREGV,0101B>
         ENDM

; Pop Data Off Stack
@POP     MACRO    dst
         @@DREG80 dst,PSW
         @80_F2   <11B,@@DREGV,0001B>
         ENDM

; Double Add (to HL)
@DAD     MACRO    src
         @@DREG80 src,SP
         @80_F2   <00B,@@DREGV,1001B>
         ENDM

; Increment Register Pair
@INX     MACRO    dst
         @@DREG80 dst,SP
         @80_F2   <00B,@@DREGV,0011B>
         ENDM

; Decrement Register Pair
@DCX     MACRO    dst
         @@DREG80 dst,SP
         @80_F2   <00B,@@DREGV,1011B>
         ENDM

; Exchange Registers  (DE <-> HL)
@XCHG    MACRO
         DB       0EBh
         ENDM

; Exchange Stack (HL <-> TOS)
@XTHL    MACRO
         DB       0E3h
         ENDM

; Load SP From HAnd L
@SPHL    MACRO
         DB       0F9h
         ENDM


; Immediate Instructions (p.25)

; Load Register Pair Immediate
@LXI     MACRO    dst,adr
         @@DREG80 dst,SP
         @80_F2   <00B,@@DREGV,0001B >
         DW       adr
         ENDM

; Move Immediate Data
@MVI     MACRO    dst,data
         @@SREG80 dst
         DB @80_F4   <00B,@@SREGV,110B>,data
         ENDM
; Add Immediate to Accumulator
@ADI     MACRO    data
         DB       0C6h,data
         ENDM

; Add Immediate to Accumulator With Carry
@ACI     MACRO    data
         DB       0CEh,data
         ENDM

; Subtract Immediate From Accumulator
@SUI     MACRO    data
         DB       0D6h,data
         ENDM

; Subtract Immediate From Accumulator With Borrow
@SBI     MACRO    data
         DB       0DEh,data
         ENDM

; And Immediate With Accumulator
@ANI     MACRO    data
         DB       0E6h,data
         ENDM

; Exclusive-Or Immediate With Accumulator
@XRI     MACRO    data
         DB       0EEh,data
         ENDM

; Or Immediate With Accumulator
@ORI     MACRO    data
         DB       0F6h,data
         ENDM

; Compare Immediate With Accumulator
@CPI     MACRO    data
         DB       0FEh,data
         ENDM


; Direct Addressing Instructions

; Store Accumulator Direct
@STA     MACRO    addr
         DB       032h
         DW       addr
         ENDM

; Load Accumulator Direct
@LDA     MACRO    addr
         DB       03Ah
         DW       addr
         ENDM

; Store Hand L Direct
@SHLD    MACRO    addr
         DB       032h
         DW       addr
         ENDM

; Load Hand L Direct
@LHLD    MACRO    addr
         DB       02Ah
         DW       addr
         ENDM


; Jump Instructions (p.31)

; Load Program Counter (HL -> PC)
@PCHL    MACRO
         DB       0E9h
         ENDM

; Jump
@JMP     MACRO    dest
         DB       0C3h
         DW       dest
         ENDM

; Jump If Carry
@JC      MACRO    dest
         DB       0DAh
         DW       dest
         ENDM

; Jump If No Carry
@JNC     MACRO    dest
         DB       0D2h
         DW       dest
         ENDM

; Jump If Zero
@JZ      MACRO    dest
         DB       0CAh
         DW       dest
         ENDM

; Jump If Not Zero
@JNZ     MACRO    dest
         DB       0C2h
         DW       dest
         ENDM

; Jump If Minus
@JM      MACRO    dest
         DB       0FAh
         DW       dest
         ENDM

; Jump If Positive
@JP      MACRO    dest
         DB       0F2h
         DW       dest
         ENDM

; Jump If Parity Even
@JPE     MACRO    dest
         DB       0EAh
         DW       dest
         ENDM

; Jump If Parity Odd
@JPO     MACRO    dest
         DB       0E2h
         DW       dest
         ENDM


; Call Subroutine Instructions (p.34)

; Call 
@CALL    MACRO    dest
         DB       0CDh
         DW       dest
         ENDM

; Call If Carry
@CC      MACRO    dest
         DB       0DCh
         DW       dest
         ENDM

; Call If No Carry
@CNC     MACRO    dest
         DB       0D4h
         DW       dest
         ENDM
; Call If Zero
@CZ      MACRO    dest
         DB       0CCh
         DW       dest
         ENDM

; Call If Not Zero
@CNZ     MACRO    dest
         DB       0C4h
         DW       dest
         ENDM

; Call If Minus
@CM      MACRO    dest
         DB       0FCh
         DW       dest
         ENDM

; Call If Plus
@CP      MACRO    dest
         DB       0F4h
         DW       dest
         ENDM


; Call If Parity Even
@CPE     MACRO    dest
         DB       0ECh
         DW       dest
         ENDM

; Call If Parity Odd
@CPO     MACRO    dest
         DB       0E4h
         DW       dest
         ENDM


; Return from Subroutine Instructions (p.35)

; Return
@RET     MACRO    dest
         DB       0C9h
         ENDM

; Return If Carry
@RC      MACRO    dest
         DB       0D8
         ENDM

; Return If No Carry
@RNC     MACRO    dest
         DB       0D0h
         ENDM

; Return If Zero
@RZ      MACRO    dest
         DB       0C8h
         ENDM

; Return If Not Zero
@RNZ     MACRO    dest
         DB       0C0h
         ENDM

; Return If Minus
@RM      MACRO    dest
         DB       0F8h
         ENDM

; Return If Plus
@RP      MACRO    dest
         DB       0F0h
         ENDM

; Return If Parity Even
@RPE     MACRO    dest
         DB       0E8h
         ENDM

; Return If Parity Odd
@RPO     MACRO    dest
         DB       0E0h
         ENDM

; RST Instruction (p.37)

; Restart
@RST     MACRO    vect
         IF       vect GE 0 AND vect LE 7
@@VECT   =        vect
         ELSE
@@VECT   =        0
          IF2
         .ERR     Vector number must be in range 0..7
         %OUT     Vector number must be in range 0..7
          ENDIF
         ENDIF
         @80_F4   <11B,@@VECT,111B>
         ENDM


; Interrupt Flip-Flop Instructions (p.38)

; Enable Interrupts (STI bei NEC) 
@EI      MACRO
         DB       0FBh
         ENDM

; Disable Interrupts (CLI bei NEC)
@DI      MACRO
         DB       0F3h
         ENDM

; Input/Output Instructions (p.38)

; Input (Port to A)
@IN      MACRO    port
         DB       0DBh,port
         ENDM

; Ouput (A to Port)
@OUT     MACRO    port
         DB       0D3h,port
         ENDM

; Halt Instruction (p.39)

; Halt
@HLT     MACRO
         DB       076h
         ENDM

         ENDIF
         .CREF
         .LIST
